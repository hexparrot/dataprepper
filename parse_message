#!/usr/bin/env python3
import sys
import json
from xform.aimlogs_parser import AimLogsParser
from xform.fbchat_parser import FbchatParser
from xform.msn_parser import MsnParser
from xform.gvoice_parser import GvoiceParser
from xform.gchat_parser import GchatParser
from xform.format_a_parser import FormatAParser
from xform.format_b_parser import FormatBParser
from xform.format_c_parser import FormatCParser
from xform.format_d_parser import FormatDParser


def main():
    """
    Main function to parse messages from either HTML or JSON input.
    - If `--json` is provided, only JSON parsers are used.
    - If `--html` is provided, only HTML parsers are used.
    - If **no flag** is provided, **all parsers** are used, and the best-performing one is selected.
    """

    # Validate command-line arguments
    valid_flags = {"--json", "--html"}
    input_type = None
    date_str = "1970-01-01"

    if len(sys.argv) > 1:
        if sys.argv[1] in valid_flags:
            input_type = sys.argv[1]
            if len(sys.argv) == 3:
                date_str = sys.argv[2]
        elif len(sys.argv) == 2:
            date_str = sys.argv[1]
        else:
            print(
                "Usage: ./parse_message [--json | --html] [YYYY-MM-DD]", file=sys.stderr
            )
            sys.exit(1)

    # Validate the date format if provided
    if len(date_str) != 10 or not (
        date_str[4] == "-"
        and date_str[7] == "-"
        and date_str[:4].isdigit()
        and date_str[5:7].isdigit()
        and date_str[8:].isdigit()
    ):
        print("Invalid date format. Use YYYY-MM-DD.", file=sys.stderr)
        sys.exit(1)

    # Read content from stdin
    raw_content = sys.stdin.read().strip()

    # Initialize JSON and HTML parsers
    json_parsers = {
        "Gchat": GchatParser(),
    }

    html_parsers = {
        "AimLogs": AimLogsParser(date_str=date_str),
        "Fbchat": FbchatParser(),
        "Msn": MsnParser(),
        "Gvoice": GvoiceParser(),
        # "FormatA": FormatAParser(),
        # "FormatB": FormatBParser(),
        # "FormatC": FormatCParser(date_str=date_str),
        # "FormatD": FormatDParser(date_str=date_str),
    }

    # Determine which parsers to run
    if input_type == "--json":
        selected_parsers = json_parsers
    elif input_type == "--html":
        selected_parsers = html_parsers
    else:
        selected_parsers = {**json_parsers, **html_parsers}  # Run all parsers

    best_parser = None
    best_records = []
    parser_performance = {}

    # Attempt to parse with the appropriate parsers
    for parser_name, parser in selected_parsers.items():
        try:
            if input_type == "--json" or (
                input_type is None and raw_content.startswith("{")
            ):
                records = parser.parse(raw_content)
            else:
                records = parser.parse(raw_content)

            parser_performance[parser_name] = len(records)

            if len(records) > len(best_records):
                best_parser = parser_name
                best_records = records

        except Exception as e:
            print(f"Error with {parser_name}: {e}", file=sys.stderr)
            parser_performance[parser_name] = 0

    # Output parsed records in standard format
    print(json.dumps(best_records, indent=4))

    # Report parser performance and chosen parser to stderr
    print("\nParser Performance:", file=sys.stderr)
    for parser_name, record_count in parser_performance.items():
        print(f"{parser_name}: {record_count} records parsed", file=sys.stderr)

    print(
        f"\nBest Parser: {best_parser} ({len(best_records)} records)", file=sys.stderr
    )


if __name__ == "__main__":
    main()
