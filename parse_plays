#!/usr/bin/env python3
import sys
import json
from xform.youtube_parser import YouTubeParser
from xform.netflix_parser import NetflixParser
from xform.netflix_games_parser import NetflixGamesParser
from xform.format_a_parser import FormatAParser
from xform.format_b_parser import FormatBParser
from xform.format_c_parser import FormatCParser
from xform.format_d_parser import FormatDParser
from xform.myanimelist_parser import MyAnimeListParser
import xml.etree.ElementTree as ET


def main():
    """
    Main function to parse messages from either HTML, JSON, CSV, or XML input.
    - If `--json` is provided, only JSON parsers are used.
    - If `--html` is provided, only HTML parsers are used.
    - If `--csv` is provided, only CSV parsers are used.
    - If `--xml` is provided, only XML parsers are used.
    - If **no flag** is provided, **all parsers** are used, and the best-performing one is selected.
    """

    # Validate command-line arguments
    valid_flags = {"--json", "--html", "--csv", "--xml"}
    input_type = None
    date_str = "1970-01-01"

    if len(sys.argv) > 1:
        if sys.argv[1] in valid_flags:
            input_type = sys.argv[1]
            if len(sys.argv) == 3:
                date_str = sys.argv[2]
        elif len(sys.argv) == 2:
            date_str = sys.argv[1]
        else:
            print(
                "Usage: ./parse_plays [--json | --html | --csv | --xml] [YYYY-MM-DD]",
                file=sys.stderr,
            )
            sys.exit(1)

    # Validate the date format if provided
    if len(date_str) != 10 or not (
        date_str[4] == "-"
        and date_str[7] == "-"
        and date_str[:4].isdigit()
        and date_str[5:7].isdigit()
        and date_str[8:].isdigit()
    ):
        print("Invalid date format. Use YYYY-MM-DD.", file=sys.stderr)
        sys.exit(1)

    # Read content from stdin
    raw_content = sys.stdin.read().strip()

    # Initialize JSON, HTML, CSV, and XML parsers
    json_parsers = {
        # Add any JSON-based parsers here
    }

    html_parsers = {
        "YouTube": YouTubeParser(),
        # Add other HTML parsers if necessary
    }

    csv_parsers = {
        "Netflix": NetflixParser(),
        "NetflixGames": NetflixGamesParser(),
    }

    xml_parsers = {
        "MyAnimeList": MyAnimeListParser(),
    }

    # Determine which parsers to run based on flag
    if input_type == "--json":
        selected_parsers = json_parsers
    elif input_type == "--html":
        selected_parsers = html_parsers
    elif input_type == "--csv":
        selected_parsers = csv_parsers
    elif input_type == "--xml":
        selected_parsers = xml_parsers
    else:
        selected_parsers = {
            **json_parsers,
            **html_parsers,
            **csv_parsers,
            **xml_parsers,
        }  # Run all parsers

    best_parser = None
    best_records = []
    parser_performance = {}

    # Attempt to parse with the appropriate parsers
    for parser_name, parser in selected_parsers.items():
        try:
            records = parser.parse(raw_content)

            parser_performance[parser_name] = len(records)

            if len(records) > len(best_records):
                best_parser = parser_name
                best_records = records

        except Exception as e:
            print(f"Error with {parser_name}: {e}", file=sys.stderr)
            parser_performance[parser_name] = 0

    # Output parsed records in standard format
    print(json.dumps(best_records, indent=4))

    # Report parser performance and chosen parser to stderr
    print("\nParser Performance:", file=sys.stderr)
    for parser_name, record_count in parser_performance.items():
        print(f"{parser_name}: {record_count} records parsed", file=sys.stderr)

    print(
        f"\nBest Parser: {best_parser} ({len(best_records)} records)", file=sys.stderr
    )


if __name__ == "__main__":
    main()
